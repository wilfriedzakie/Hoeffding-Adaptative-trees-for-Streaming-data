from skmultiflow.classification.trees.hoeffding_tree import HoeffdingTree
from skmultiflow.classification.naive_bayes import NaiveBayes
from skmultiflow.classification.core.driftdetection.adwin import ADWIN
from abc import ABCMeta, abstractmethod
from skmultiflow.core.utils.utils import *
from #skmultiflow.core.utils.file_scripts import Norma


class HoeffdingAdaptiveTree(HoeffdingTree):

    def __init__(self, max_byte_size=33554432, memory_estimate_period=1000000, grace_period=200,
                 split_criterion='info_gain', split_confidence=0.0000001, tie_threshold=0.05, binary_split=False,
                 stop_mem_management=False, remove_poor_atts=False, no_preprune=False, leaf_prediction='mc',
                 nb_threshold=0, nominal_attributes=None):
        """HoeffdingTree class constructor."""
        super().__init__()
        self._tree_root = None
        self._decision_node_cnt = 0
        self._active_leaf_node_cnt = 0
        self._inactive_leaf_node_cnt = 0
        self._inactive_leaf_byte_size_estimate = 0.0
        self._active_leaf_byte_size_estimate = 0.0
        self._byte_size_estimate_overhead_fraction = 1.0
        self._growth_allowed = True
        self._train_weight_seen_by_model = 0.0
        self.updateSplitterCounts = 0.0
        self.byteSize = 0
        self._estimationErrorWeight: ADWIN

    class NewNode(metaclass= ABCMeta):

        @abstractmethod
        def numberLeaves(self):
            pass

        @abstractmethod
        def getErrorEstimation(self):
            pass

        @abstractmethod
        def getErrorWidth(self):
            pass

        @abstractmethod
        def isNullError(self):
            pass

        @abstractmethod
        def killTreeChilds(self, ht):
            pass

        @abstractmethod
        def learnFromInstance(self, X,y, ht,parent:HoeffdingTree.SplitNode, parentBranch:int):
            pass

        @abstractmethod
        def filterInstanceToLeaves(self,X,y, myparent:HoeffdingTree.SplitNode,
                                   parentBranch:int, foundNodes, updateSplitterCounts:bool):
            pass

    class AdaLearningNode(HoeffdingTree.SplitNode,NewNode):

        def __init__(self):
            self.estimationErrorWeight: ADWIN
            self.ErrorChange = False
            self.alternateTree: HoeffdingTree.Node


        def __init__(self,alternateTree):
            self.estimationErrorWeight: ADWIN
            self.ErrorChange = False
            self.alternateTree: HoeffdingTree.Node=alternateTree


        def calcByteSize(self):
            byteSize = super.calcByteSize()

            if self.estimationErrorWeight is not None:
                byteSize += self.estimationErrorWeight.measureByteSize()
            return byteSize

        def getErrorEstimation(self):
            if self.estimationErrorWeight is not None:
                return self.estimationErrorWeight.getEstimation()
            else:
                return 0

        def getErrorWidth(self):
            w = 0.0
            if (self.isNullError() == False):
                w = self.estimationErrorWeight.getWidth()
            return w

        def isNullError(self):
            return self.estimationErrorWeight is None

        def numberLeaves(self):
            return 1

        def learnfromInstance(self, X, y, ht, parent: HoeffdingTree.SplitNode, parentBranch: int):
            ClassPrediction = 0
            if (HoeffdingTree.SplitNode.filter_instance_to_leaf(X, parent, parentBranch).node is None):
                ClassPrediction = HoeffdingTree.Node(
                    HoeffdingTree.SplitNode.filter_instance_to_leaf(X, parent, parentBranch).node).get_class_votes(X,
                                                                                                                   ht)

            blCorrect = (y == ClassPrediction)

            if self.estimationErrorWeight is None:
                self.estimationErrorWeight = ADWIN()
            oldError = self.getErrorEstimation()
            self.ErrorChange = self.estimationErrorWeight.setInput(0.0 if blCorrect == True else 1.0)

            if self.ErrorChange == True and oldError > self.getErrorEstimation():
                self.ErrorChange = False

            if (self.ErrorChange == True):
                self.alternateTree = ht.newLearningNode()
                ht.alternateTrees += 1
            ##To check
            elif self.alternateTree is None and (self.alternateTree).isNullError() == False:
                if self.getErrorWidth() > 300 and (self.alternateTree).getErrorWidth() > 300:
                    oldErrorRate = self.getErrorEstimation()
                    altErrorRate = (self.alternateTree).getErrorEstimation()
                    fDelta = .05

                    fn = 1.0 / ((self.alternateTree).getErrorWidth()) + 1.0 / (self.getErrorWidth())
                    bound = ht.compute_hoeffding_bound()
                    if (bound < oldErrorRate - altErrorRate):
                        self.activeLeafNodeCount -= self.numberLeaves()
                        self.activeLeafNodeCount += self.alternateTree.numberLeaves()

                        self.kill_tree_childs(ht)##

                        if (parent is not None):
                            parent.setChild(parentBranch, self.alternateTree)
                        else:

                            adaSplitNodeTree=HoeffdingAdaptiveTree.AdaSplitNode(ht.tree_root)

                            ht._tree_root = ht._tree_root.alternateTree

                            ht.switchedAlternateTrees +=1
                    elif bound < altErrorRate - oldErrorRate:
                        if isinstance(self.alternateTree, HoeffdingTree.ActiveLearningNode):
                            self.alternateTree is None
                            ht._active_leaf_node_cnt -=1

                        elif isinstance(self.alternateTree, HoeffdingTree.InactiveLearningNode):
                            self.alternateTree is None
                            ht._inactive_leaf_node_cnt -=1

                        else:
                            (self.alternateTree).kill_tree_childs(ht)

                        ht.prunedAlternateTrees +=1

        def get_class_votes(self, X, ht):
            prediction_option = HoeffdingAdaptiveTree.leafpredictionOption.getChosenIndex()

            if prediction_option is None:
                dist = self.observedClassDistribution.getArrayCopy()

            elif prediction_option == 1:

                dist = NaiveBayes.doNaiveBayesPrediction(X, self.observedClassDistribution, self.attributeObservers)

            else:
                if (self.mcCorrectWeight > self.nbCorrectWeight):
                    dist = self.observedClassDistribution.getArrayCopy()
                else:
                    dist = NaiveBayes.doNaiveBayesPrediction(X, self.observedClassDistribution, self.attributeObservers)

            distSum = sum(dist)
            if distSum * self.getErrorEstimation() * self.getErrorEstimation() > 0.0:
                normalize(dist, distSum * self.getErrorEstimation() * self.getErrorEstimation())
            return dist

        def filter_instance_to_leaf(self, X, parent: HoeffdingTree.SplitNode, parent_branch,
                                    fn: HoeffdingTree.FoundNode, updateSplitterCounts):
            fn.add(HoeffdingTree.FoundNode(self, parent, parent_branch))

        def new_learning_node(initial_class_observations):
            return HoeffdingAdaptiveTree.AdaLearningNode(initial_class_observations)

        def new_split_node(split_test, class_observations):
            return HoeffdingAdaptiveTree.AdaSplitNode(split_test, class_observations)

        def train_on_instanceImpl(self, X):
            if self._tree_root is None:
                self._tree_root = self._new_learning_node()
                self._active_leaf_node_cnt = 1

            # ((NewNode) self._tree_root).learn_from_instance(X, self, None, -1)

    # def filter_instance_to_leaves(self,X,parent:HoeffdingTree.SplitNode, parentBranch:int, update_splitter_counts);

    def get_votes_for_instance(self, X):
        if self._tree_root is not None:
            found_node = self._tree_root.filter_instance_to_leaf(X, None, -1, False)

            predictionPaths = 0

            if found_node.parent is not -1:

                leaf_node = found_node.node
                if leaf_node is None:
                    leaf_node = found_node.parent

                    dist = leaf_node.get_class_votes(X, self)

            return leaf_node.get_class_votes(X, self)
        else:
            return {}

    class AdaSplitNode(HoeffdingTree.SplitNode):

        def __init__(self, split_test, class_observations, size=-1):
            """SplitNode class constructor."""
            self.numLeaves = 0

        def calc_byte_size_including_subtree(self):
            byteSize = HoeffdingTree.measure_byte_size()

            if self.alternateTree is not None:
                byteSize += self.alteranteTree.calc_byte_size_including_subtree()
            if self.estimationErrorWeight is not None:
                byteSize += self.estimationErrorWeight.measureByteSize()

                for child in self._children:
                    if child is not None:
                        byteSize += child.calc_byte_size_including_subtree()
            return byteSize

        def number_leaves(self):
            numleaves = 0
            for child in self._children:
                if child is not None:
                    numleaves += child.number_leaves()
            return numleaves + 1

        def getErrorEstimation(self):
            return self.estimationErrorWeight.getErrorEstimation()

        def isNullError(self):
            return self.estimationErrorWeight is None

        def getErrorWidth(self):
            self.w = 0.0
            if self.isNullError() is False:
                w = self.estimationErrorWeight.getWidth()
            return w

        def kill_tree_childs(HoeffdingAdaptiveTree, self):

            for child in self._children:

                if child is not None:
                    if isinstance(child,
                                  HoeffdingAdaptiveTree.AdaSplitNode) and HoeffdingAdaptiveTree.AdaSplitNode.alternateTree is not None:
                        HoeffdingAdaptiveTree.AdaSplitNode.kill_tree_childs(HoeffdingTree)

                        HoeffdingTree.prunedAlternateTrees

                    if isinstance(child, HoeffdingTree.AdaSplitNode):
                        child.kill_tree_childs(HoeffdingTree)

                    if isinstance(child, HoeffdingTree.ActiveLearningNode):
                        child is None
                        self._active_leaf_node_cnt -= 1


                    elif isinstance(child, HoeffdingTree.InactiveLearningNode):
                        child is None
                        self._active_leaf_node_cnt -= 1

        def filter_instance_to_leaf(self, X, parent: HoeffdingTree.SplitNode, parent_branch,
                                    fn: HoeffdingTree.FoundNode, updateSplitterCounts):

            if updateSplitterCounts:
                self.get_observed_class_distribution(X)
                childIndex = self.instance_child_index(X)

                if childIndex >= 0:
                    child = self.get_child(childIndex)

                    if child is not None:
                        return child.filter_instance_to_leaf(X, self, childIndex, fn, updateSplitterCounts)
                else:
                    return fn.FoundNode(None, self, childIndex)

                if self.alteranteTree is not None:
                    return self.alternateTree.filter_instance_to_leaf(X, self, fn, updateSplitterCounts)

        def _new_learning_node(self, initial_class_observations=None):

            if initial_class_observations is None:
                initial_class_observations = {}
                if self._leaf_prediction ==:

                    return self.ActiveLearningNode(initial_class_observations)
                elif self._leaf_prediction == NaiveBayes:
                    return self.LearningNodeNB(initial_class_observations)
            else:
                return self.LearningNodeNBAdaptive(initial_class_observations)

        def train_on_instance_impl(X, self):
            if self._tree_root is None:
                self.treeRoot = self.new_learning_node()
                l = self._tree_root.leaf_for_instance(X, None, None)
                leaf_node = l.the_node
                if leaf_node is None:
                    leaf_node = self._new_learning_node()
                    l.parent_node.set_child(l.parent_branch, leaf_node)

                    if isinstance(leaf_node, HoeffdingTree.InactiveLearningNode):
                        leaf_node.update_node(X)
                        if isinstance(leaf_node, self._new_learning_node):
                            leaf_node.update_node(X)
                            weightSeen = leaf_node.weightSeen()
                            if weightSeen - leaf_node.weight_seen_at_last_split_eval > self._grace_period:
                                self.try_split(leaf_node, l.parent_node, l.parent_branch)
                                leaf_node.weight_seen_at_last_split_eval = weightSeen




