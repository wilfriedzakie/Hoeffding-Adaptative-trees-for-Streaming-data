from skmultiflow.classification.trees.hoeffding_tree import HoeffdingTree
from skmultiflow.classification.naive_bayes import NaiveBayes
from skmultiflow.classification.core.driftdetection.adwin import ADWIN
from abc import ABCMeta,abstractmethod


class HoeffdingAdaptiveTree(HoeffdingTree):


    def __init__(self, max_byte_size=33554432, memory_estimate_period=1000000, grace_period=200,
                 split_criterion='info_gain', split_confidence=0.0000001, tie_threshold=0.05, binary_split=False,
                 stop_mem_management=False, remove_poor_atts=False, no_preprune=False, leaf_prediction='mc',
                 nb_threshold=0, nominal_attributes=None):
        """HoeffdingTree class constructor."""
        super().__init__()
        self._tree_root = None

        self._active_leaf_node_cnt = 0
        self._inactive_leaf_node_cnt = 0

        self.updateSplitterCounts = 0.0
        self.byte_size = 0
        self._estimationErrorWeight:ADWIN



    class NewNode(metaclass= ABCMeta):

        @abstractmethod
        def numberLeaves(self):
            pass

        @abstractmethod
        def getErrorEstimation(self):
            pass

        @abstractmethod
        def getErrorWidth(self):
            pass

        @abstractmethod
        def isNullError(self):
            pass

        @abstractmethod
        def killTreeChilds(self, ht):
            pass

        @abstractmethod
        def learnFromInstance(self, X,y, ht,parent:HoeffdingTree.SplitNode, parentBranch:int):
            pass

        @abstractmethod
        def filterInstanceToLeaves(self,X,y, myparent:HoeffdingTree.SplitNode,
                                   parentBranch:int, foundNodes, updateSplitterCounts:bool):
            pass



    class AdaSplitNode(HoeffdingTree.SplitNode):

        def __init__(self, split_test, class_observations, size=-1):
            """SplitNode class constructor."""
            self.numLeaves = 0


        def calc_byte_size_including_subtree(self):
            byteSize = HoeffdingTree.measure_byte_size()

            if self.alternateTree is not None:
                byteSize += self.alteranteTree.calc_byte_size_including_subtree()
            if self.estimationErrorWeight is not None:
                byteSize += self.estimationErrorWeight.measureByteSize()

                for child in self._children:
                    if child is not None:
                        byteSize += child.calc_byte_size_including_subtree()
            return byteSize

        def number_leaves(self):
            numleaves = 0
            for child in self._children:
                if child is not None:
                    numleaves += child.number_leaves()
            return numleaves + 1

        def getErrorEstimation(self):
            return self.estimationErrorWeight.getErrorEstimation()

        def isNullError(self):
            return self.estimationErrorWeight is None

        def getErrorWidth(self):
            self.w = 0.0
            if self.isNullError() is False:
                w = self.estimationErrorWeight.getWidth()
            return w


        def learn_from_instance(self,X,y, ht, parent:HoeffdingTree.SplitNode, parent_branch:int):
            class_prediction =0
            if HoeffdingTree.SplitNode.filter_instance_to_leaf(X,y,parent,parent_branch).node is None :
                class_prediction = HoeffdingTree.Node(HoeffdingTree.SplitNode.filter_instance_to_leaf(X,y,parent,parent_branch).node).get_class_votes(X,ht)

            bl_correct = (y == class_prediction)

            if self.estimationErrorWeight is None :
                self.estimationErrorWeight = ADWIN()
            old_error = self.get_error_estimation()
            self.error_change = self.estimationErrorWeight.setInput(0.0 if bl_correct == True else  1.0)

            if self.error_change == True and old_error > self.get_error_estimation():
                self.error_change == False

            if self.error_change:
                self.alternateTree = ht.newLearningNode()
                ht.alternateTrees +=1


            ##To check
            elif self.alternateTree is None and (self.alternateTree).is_null_error() == False :
                if self.get_error_width() > 300 and  self.alternateTree.get_error_width() > 300:
                    old_error_rate = self.get_error_estimation()
                    alt_error_rate =  self.alternateTree.get_error_estimation()
                    fDelta = .05

                    fn = 1.0 / (self.alternateTree.get_error_width()) + 1.0 / (self.get_error_width())
                    bound = HoeffdingTree.compute_hoeffding_bound()
                    if bound < old_error_rate - alt_error_rate:
                        self._active_leaf_node_cnt -= self.numberLeaves()
                        self._active_leaf_node_cnt += self.alternateTree.numberLeaves()

                        kill_tree_childs(HoeffdingTree)

                        if parent is not None:
                            parent.setChild(parent_branch, self.alternateTree)
                        else :
                            HoeffdingTree._tree_root = HoeffdingAdaptiveTree.AdaSplitNode._tree_root.alternateTree

                            HoeffdingTree.switchedAlternateTrees += 1
                    elif bound < alt_error_rate - old_error_rate:
                        if isinstance(self.alternateTree, HoeffdingTree.ActiveLearningNode):
                            self.alternateTree is None
                            self._active_leaf_node_cnt -= 1

                    elif isinstance(self.alternateTree, HoeffdingTree.InactiveLearningNode):
                        self.alternateTree is None
                        self._inactive_leaf_node_cnt -= 1

                    else :
                        ((HoeffdingAdaptiveTree.AdaSplitNode) self.alternateTree).kill_tree_childs(HoeffdingTree)
                        self.prunedAlternateTrees += 1

                    if self.alternateTree is not None:
                        self.alternateTree.learn_from_instance(weight_instance, ht, parent, parent_branch)

                    child_branch = self.instance_child_index(X,y)
                    child = self.get_child(child_branch)

                    if child is not None:
                        child.filter_instance_to_leaf(weight_instance, ht, self, child_branch)


        def kill_tree_childs(HoeffdingAdaptiveTree, self):

            for child in self._children:

                if child is not None:
                    if isinstance(child,
                                  HoeffdingAdaptiveTree.AdaSplitNode) and HoeffdingAdaptiveTree.AdaSplitNode.alternateTree is not None:
                        HoeffdingAdaptiveTree.AdaSplitNode.kill_tree_childs(HoeffdingTree)

                        HoeffdingTree.prunedAlternateTrees

                    if isinstance(child, HoeffdingTree.AdaSplitNode):
                        child.kill_tree_childs(HoeffdingTree)

                    if isinstance(child, HoeffdingTree.ActiveLearningNode):
                        child is None
                        self._active_leaf_node_cnt -= 1


                    elif isinstance(child, HoeffdingTree.InactiveLearningNode):
                        child is None
                        self._active_leaf_node_cnt -= 1



        def filter_instance_to_leaf(self, X,y, parent:HoeffdingTree.SplitNode, parent_branch,
                                    fn:HoeffdingTree.FoundNode, updateSplitterCounts):

            if updateSplitterCounts:
                self.get_observed_class_distribution(X,y)
                child_index = self.instance_child_index(X,y)

                if child_index >= 0:
                    child = self.get_child(child_index)

                    if child is not None:
                        return child.filter_instance_to_leaf(X,y, self, child_index, fn, updateSplitterCounts)
                else:
                    return fn.FoundNode(None, self, child_index)

                if self.alteranteTree is not None:
                    return  self.alternateTree.filter_instance_to_leaf(X,y, self, fn, updateSplitterCounts)



    class AdaLearningNode(HoeffdingTree.SplitNode, NewNode):

        def __init__(self):
            self.estimationErrorWeight: ADWIN
            self.ErrorChange = False
            self.alternateTree: HoeffdingTree.Node


        def calcByteSize(self):
            byteSize = super.calcByteSize()

            if self.estimationErrorWeight is not None:
                byteSize += self.estimationErrorWeight.measureByteSize()
            return byteSize

        def getErrorEstimation(self):
            if self.estimationErrorWeight is not None:
                return self.estimationErrorWeight.getEstimation()
            else:
                return 0


        def getErrorWidth(self):
            w = 0.0
            if (self.isNullError() == False):
                w = self.estimationErrorWeight.getWidth()
                return w

        def isNullError(self):
            return self.estimationErrorWeight is None

        def numberLeaves(self):
            return 1


        def kill_tree_childs(hoeffding_adaptive_tree):
            return



        def learnfromInstance(self, X, y, ht, parent: HoeffdingTree.SplitNode, parentBranch: int):
            ClassPrediction = 0
            if (HoeffdingTree.SplitNode.filter_instance_to_leaf(X, parent, parentBranch).node is None):
                ClassPrediction = HoeffdingTree.Node(
                    HoeffdingTree.SplitNode.filter_instance_to_leaf(X, parent, parentBranch).node).get_class_votes(X,
                                                                                                                   ht)


            blCorrect = (y == ClassPrediction)

            if self.estimationErrorWeight is None:
                self.estimationErrorWeight = ADWIN()
            oldError = self.getErrorEstimation()
            self.ErrorChange = self.estimationErrorWeight.setInput(0.0 if blCorrect == True else 1.0)

            if self.ErrorChange == True and oldError > self.getErrorEstimation():
                self.ErrorChange = False

            learnfromInstance(weighted_inst, ht)

            weight_seen = ht.get_width_seen()

            if weight_seen - ht.get_weight_seen_at_last_split_evaluation() >= HoeffdingTree.grace_period.getValue() :
                ht._attempt_to_split(self, parent, parentBranch)
                ht.set_weight_seen_at_last_split_evaluation(weight_seen)


        def get_class_votes(self, X,y, ht):

            prediction_option = HoeffdingAdaptiveTree.leafpredictionOption.getChosenIndex()
            if prediction_option is None:
                dist = self.observedClassDistribution.getArrayCopy()
            elif prediction_option == 1 :
                dist = NaiveBayes.doNaiveBayesPrediction(X,y, self.observedClassDistribution, self.attributeObservers)
            else :
                if self.mcCorrectWeight > self.nbCorrectWeight :
                    dist = self.observedClassDistribution.getArrayCopy()
                else :
                    dist = NaiveBayes.doNaiveBayesPrediction(X,y, self.observedClassDistribution, self.attributeObservers)

            distSum = sum(dist)
            if distSum * self.getErrorEstimation() * self.get_error_estimation() > 0.0:
                normalize(dist, distSum * self.get_error_estimation() * self.get_error_estimation())
            return dist


        def filter_instance_to_leaf(self, X,y, parent:HoeffdingTree.SplitNode, parent_branch, fn:HoeffdingTree.FoundNode, updateSplitterCounts):
            fn.add(HoeffdingTree.FoundNode(self, parent, parent_branch))

        def new_learning_node(initial_class_observations):
            return HoeffdingAdaptiveTree.AdaLearningNode(initial_class_observations)

        def new_split_node(split_test, class_observations):
            return HoeffdingAdaptiveTree.AdaSplitNode(split_test, class_observations)

        def train_on_instance_impl(self, X,y):
            if self._tree_root is None:
                self._tree_root = self._new_learning_node()
                self._active_leaf_node_cnt = 1

            ((NewNode) self._tree_root).learn_from_instance(X, self, None, -1)







    def get_votes_for_instance(self, X,y):
        if self._tree_root is not None:
            found_node = self._tree_root.filter_instance_to_leaf(X,y, None, -1, False)

            predictionPaths = 0

            if found_node.parent is not -1:

                leaf_node = found_node.node
                if leaf_node is None:
                    leaf_node = found_node.parent

                    dist = leaf_node.get_class_votes(X,y, self)

            return leaf_node.get_class_votes(X,y, self)
        else:
            return {}


    def _new_learning_node(self, initial_class_observations=None):

            if initial_class_observations is None:
                initial_class_observations = {}
                if self._leaf_prediction == :

                    return self.ActiveLearningNode(initial_class_observations)
                elif self._leaf_prediction == NaiveBayes:
                    return self.LearningNodeNB(initial_class_observations)
            else:
                return self.LearningNodeNBAdaptive(initial_class_observations)



        def train_on_instance_impl(X,y, self):
            if self._tree_root is None:
             self.treeRoot = self.new_learning_node()
             l = self._tree_root.leaf_for_instance(X,y, None, None)
             leaf_node = l.the_node
             if leaf_node is None:
                 leaf_node = self._new_learning_node()
                 l.parent_node.set_child(l.parent_branch, leaf_node)

                 if isinstance(leaf_node, HoeffdingTree.InactiveLearningNode):
                     leaf_node.update_node(X,y)
                     if isinstance(leaf_node, self._new_learning_node):
                         leaf_node.update_node(X,y)
                         weightSeen = leaf_node.weightSeen()
                         if weightSeen - leaf_node.weight_seen_at_last_split_eval > self._grace_period:
                             self.try_split(leaf_node, l.parent_node, l.parent_branch)
                             leaf_node.weight_seen_at_last_split_eval = weightSeen



